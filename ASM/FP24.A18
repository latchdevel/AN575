;	RCS Header $Id: fp24.a18 2.8 1996/12/21 20:59:37 F.J.Testa Exp $

;	$Revision: 2.8 $

;       PIC18 24 BIT FLOATING POINT LIBRARY
;
;       Unary operations: both input and output are in AEXP,AARG
;
;       Binary operations: input in AEXP,AARG and BEXP,BARG with output in AEXP,AARG
;
;       All routines return WREG = 0x00 for successful completion, and WREG = 0xFF
;       for an error condition specified in FPFLAGS.
;
;       Max timings are worst case cycle counts, while Min timings are non-exception
;       best case cycle counts.
;
;         Routine               Function
;
;       FLO1624         16 bit integer to 24 bit floating point conversion
;       FLO24
;
;       Max Timing:                RND
;                               0       1
;
;                       0       48      48
;                  SAT
;                       1       55      55
;
;       NRM2424  24 bit normalization of unnormalized 24 bit floating point numbers
;       NRM24
;
;       Max Timing:                RND
;                               0       1
;
;                       0       39      39
;                  SAT
;                       1       46      46
;
;
;       INT2416         24 bit floating point to 16 bit integer conversion
;       INT24
;
;       Max Timing:                RND
;                               0       1
;
;                       0       58      66
;                  SAT
;                       1       58      70
;
;       FLO2424         24 bit integer to 24 bit floating point conversion
;
;       Max Timing:                RND
;                               0       1
;
;                       0       64      77
;                  SAT
;                       1       64      83
;
;       NRM3224 24 bit normalization of unnormalized 32 bit floating point numbers
;
;       Max Timing:                RND
;                               0       1
;
;                       0       52      65
;                  SAT
;                       1       52      71
;
;
;       INT2424         24 bit floating point to 24 bit integer conversion
;
;       Max Timing:                RND
;                               0       1
;
;                       0       71      79
;                  SAT
;                       1       71      82
;
;       FPA24           24 bit floating point add
;
;       Max Timing:                RND
;                               0       1
;
;                       0       133     146
;                  SAT
;                       1       133     152
;
;       FPS24           24 bit floating point subtract
;
;       Max Timing:                RND
;                               0       1
;
;                       0       134     147
;                  SAT
;                       1       134     153
;
;       FPM24           24 bit floating point multiply
;
;       Max Timing:                RND
;                               0       1
;
;                       0       60      72
;                  SAT
;                       1       60      79
;
;       FPD24           24 bit floating point divide
;
;       Max Timing:                RND
;                               0       1
;
;                       0       176     185
;                  SAT
;                       1       176     192
;
;**********************************************************************************************
;**********************************************************************************************

;       24 bit floating point representation

;       EXPONENT        8 bit biased exponent

;                       It is important to note that the use of biased exponents produces
;                       a unique representation of a floating point 0, given by
;                       EXP = HIGHBYTE = LOWBYTE = 0x00, with 0 being the only
;                       number with EXP = 0.

;       HIGHBYTE        8 bit most significant byte of fraction in sign-magnitude representation,
;                       with SIGN = MSB, implicit MSB = 1 and radix point to the right of MSB

;       LOWBYTE         8 bit least significant byte of sign-magnitude fraction

;       EXPONENT        HIGHBYTE        LOWBYTE

;       xxxxxxxx        S.xxxxxxx       xxxxxxxx

;                        |
;                      RADIX
;                      POINT



;**********************************************************************************************
;**********************************************************************************************

;       Integer to float conversion

;       Input:  16 bit 2's complement integer right justified in AARGB0, AARGB1

;       Use:    CALL    FLO1624
;               CALL    FLO24

;       Output: 24 bit floating point number in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  FLOAT( AARG )

;       Max Timing:     9+39 = 48 clks          SAT = 0
;                       9+45 = 54 clks          SAT = 1

;       Min Timing:     6+15 = 21 clks          AARG = 0
;                       6+20 = 26 clks

;       PM: 9+68 = 77                           DM: 6

;----------------------------------------------------------------------------------------------

FLO1624

FLO24           MOVLW           0x0F+EXPBIAS		; initialize exponent and add bias
                MOVWF           EXP
                MOVFF           AARGB0,SIGN		; save sign in SIGN
                BTFSS           AARGB0,MSB		; test sign
                BRA             NRM24
                COMF            AARGB1,F 		; if < 0, negate, set MSB in SIGN
                COMF            AARGB0,F
                INFSNZ          AARGB1,F
                INCF            AARGB0,F

;**********************************************************************************************

;       Normalization routine

;       Input:  24 bit unnormalized floating point number in AEXP, AARGB0, AARGB1,
;               with sign in SIGN,MSB.

;       Use:    CALL    NRM2424
;               CALL    NRM24

;       Output: 24 bit normalized floating point number in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  NORMALIZE( AARG )

;       Max Timing:     3+12+16+8 = 39 clks             SAT = 0
;                       3+12+16+15 = 46 clks            SAT = 1

;       Min Timing:     10+5 = 15 clks                  AARG = 0
;                       3+5+4+8 = 20 clks

;       PM: 68                                          DM: 6

;----------------------------------------------------------------------------------------------

NRM2424
NRM24
		CLRF            TEMP			; clear exponent decrement
		CLRF		WREG
                CPFSGT          AARGB0			; test if highbyte=0
                BRA             NRM2424A

TNIB2424        MOVLW           0xF0                    ; test if highnibble=0
                ANDWF           AARGB0,W
                TSTFSZ          WREG
                BRA             NORM2424
                SWAPF           AARGB0,F		; if so, shift 4 bits
                SWAPF           AARGB1,W
                ANDLW           0x0F
                ADDWF           AARGB0,F
                SWAPF           AARGB1,W
                ANDLW           0xF0
                MOVWF           AARGB1

                BSF             TEMP,2                  ; increase decrement by 4

NORM2424        BCF             _C                      ; clear carry bit

                BTFSC           AARGB0,MSB		; if MSB=1, normalization done
                BRA             TNORMUN2424
                RLCF            AARGB1,F		; otherwise, shift left and 
                RLCF            AARGB0,F		; increment decrement
                INCF            TEMP,F
                BTFSC           AARGB0,MSB
                BRA             TNORMUN2424
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB		; since highnibble != 0, at most
                BRA             TNORMUN2424             ; 3 left shifts are required
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F

TNORMUN2424     MOVF            TEMP,W			; if EXP <= decrement in TEMP,
                CPFSGT          EXP                     ; floating point underflow has
                BRA             SETFUN24                ; occured
                SUBWF           EXP,F			; otherwise, compute EXP

FIXSIGN24       BTFSS           SIGN,MSB
                BCF             AARGB0,MSB		; clear explicit MSB if positive
                RETLW           0

NRM2424A        MOVFF           AARGB1,AARGB0		; if so, shift 8 bits by move
                CLRF            AARGB1
                BSF             TEMP,3                  ; increase decrement by 8       
                CPFSGT          AARGB0			; if highbyte=0, result=0
                BRA             RES024

                MOVLW           0xF0                    ; test if highnibble=0
                ANDWF           AARGB0,W
                TSTFSZ          WREG
                BRA             NORM2424A
                SWAPF           AARGB0,F                ; if so, shift 4 bits

                BSF             TEMP,2                  ; increase decrement by 4

NORM2424A       BCF             _C                      ; clear carry bit

                BTFSC           AARGB0,MSB		; if MSB=1, normalization done
                BRA             TNORMUN2424
                RLCF            AARGB0,F		; otherwise, shift left and 
                INCF            TEMP,F			; increment decrement
                BTFSC           AARGB0,MSB
                BRA             TNORMUN2424
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB		; since highnibble != 0, at most
                BRA             TNORMUN2424             ; 3 left shifts are required
                RLCF            AARGB0,F
                INCF            TEMP,F
                BRA             TNORMUN2424

RES024          CLRF            AARGB0			; result equals zero
                CLRF            AARGB1
		CLRF		AARGB2			; clear extended byte
                CLRF            EXP
                RETLW           0

;**********************************************************************************************
;**********************************************************************************************

;       Integer to float conversion

;       Input:  24 bit 2's complement integer right justified in AARGB0, AARGB1, AARGB2

;       Use:    CALL    FLO2424

;       Output: 24 bit floating point number in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  FLOAT( AARG )

;       Max Timing:     12+52 = 64 clks         RND = 0
;                       12+65 = 77 clks         RND = 1, SAT = 0
;                       12+71 = 83 clks         RND = 1, SAT = 1

;       Min Timing:     6+24 = 30 clks                  AARG = 0
;                       6+24 = 30 clks

;       PM: 12+121 = 133                                DM: 7

;----------------------------------------------------------------------------------------------

FLO2424         MOVLW           0x17+EXPBIAS		; initialize exponent and add bias
                MOVWF           EXP
                MOVFF           AARGB0,SIGN		; save sign in SIGN
                BTFSS           AARGB0,MSB		; test sign
                BRA             NRM3224
                CLRF            WREG			; if < 0, negate, set MSB in SIGN
                COMF            AARGB2,F
                COMF            AARGB1,F
                COMF            AARGB0,F
                INCF            AARGB2,F
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F

;**********************************************************************************************

;       Normalization routine

;       Input:  32 bit unnormalized floating point number in AEXP, AARGB0, AARGB1,
;               AARGB2 with sign in SIGN,MSB.

;       Use:    CALL    NRM3224

;       Output: 24 bit normalized floating point number in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  NORMALIZE( AARG )

;       Max Timing:     21+19+12 = 52 clks              RND = 0
;                       21+19+25 = 65 clks              RND = 1, SAT = 0
;                       21+19+31 = 71 clks              RND = 1, SAT = 1

;       Min Timing:     4+7+7+5 = 24 clks               AARG = 0
;                       3+5+4+8+4 = 24 clks

;       PM: 122						DM: 7

;----------------------------------------------------------------------------------------------

NRM3224         CLRF            TEMP			; clear exponent decrement
		CLRF		WREG
                CPFSGT          AARGB0			; test if highbyte=0
                BRA             NRM3224A

TNIB3224        MOVLW           0xF0                    ; test if highnibble=0
                ANDWF           AARGB0,W
                TSTFSZ          WREG
                BRA             NORM3224
                SWAPF           AARGB0,F                ; if so, shift 4 bits
                SWAPF           AARGB1,W
                ANDLW           0x0F
                ADDWF           AARGB0,F

                SWAPF           AARGB1,W
                ANDLW           0xF0
                MOVWF           AARGB1
                SWAPF           AARGB2,W
                ANDLW           0x0F
                ADDWF           AARGB1,F

                SWAPF           AARGB2,W
                ANDLW           0xF0
                MOVWF           AARGB2

                BSF             TEMP,2			; increase decrement by 4

NORM3224        BCF             _C                      ; clear carry bit

                BTFSC           AARGB0,MSB		; if MSB=1, normalization done
                BRA             TNORMUN3224
                RLCF            AARGB2,F                ; otherwise, shift left and 
                RLCF            AARGB1,F                ; increment decrement
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB
                BRA             TNORMUN3224
                RLCF            AARGB2,F
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB		; since highnibble != 0, at most
                BRA             TNORMUN3224             ; 3 left shifts are required
                RLCF            AARGB2,F
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F

TNORMUN3224     MOVF            TEMP,W	               ; if EXP <= decrement in TEMP,
                CPFSGT          EXP                     ; floating point underflow has
                BRA             SETFUN24                ; occured
                SUBWF           EXP,F			; otherwise, compute EXP

NRMRND3224
		BTFSC           FPFLAGS,RND		; is rounding enabled?
                BTFSS           AARGB2,MSB		; is NSB > 0x80?
                BRA             FIXSIGN24
		BSF		_C			; set carry for rounding
		MOVLW		0x80
		CPFSGT		AARGB2			; if NSB = 0x80, select even
		RRCF		AARGB1,W		; using lsb in carry
                CLRF            WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F

                BNC             FIXSIGN24		; has rounding caused carryout?
                RRCF            AARGB0,F                ; if so, right shift
                RRCF            AARGB1,F
                INFSNZ          EXP,F			; test for floating point overflow
                BRA             SETFOV24
                BRA             FIXSIGN24

NRM3224A        MOVFF           AARGB1,AARGB0		; shift 8 bits by move
                MOVFF           AARGB2,AARGB1
                CLRF            AARGB2
		CLRF		WREG
                BSF             TEMP,3                  ; increase decrement by 8       
                CPFSGT          AARGB0			; test if highbyte=0
                BRA             NRM3224B

TNIB3224A       MOVLW           0xF0                    ; test if highnibble=0
                ANDWF           AARGB0,W
                TSTFSZ          WREG
                BRA             NORM3224A
                SWAPF           AARGB0,F                ; if so, shift 4 bits
                SWAPF           AARGB1,W
                ANDLW           0x0F
                ADDWF           AARGB0,F

                SWAPF           AARGB1,W
                ANDLW           0xF0
                MOVWF           AARGB1

                BSF             TEMP,2                  ; increase decrement by 4

NORM3224A       BCF             _C                      ; clear carry bit

                BTFSC           AARGB0,MSB		; if MSB=1, normalization done
                BRA             TNORMUN3224
                RLCF            AARGB1,F                ; otherwise, shift left and 
                RLCF            AARGB0,F                ; increment decrement
                INCF            TEMP,F
                BTFSC           AARGB0,MSB
                BRA             TNORMUN3224
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB		; since highnibble != 0, at most
                BRA             TNORMUN3224             ; 3 left shifts are required
                RLCF            AARGB1,F
                RLCF            AARGB0,F
                INCF            TEMP,F
                BRA             TNORMUN3224

NRM3224B        MOVFF           AARGB1,AARGB0		; shift 8 bits by move
                CLRF            AARGB1
		CLRF		WREG
                BCF             TEMP,3                  ; increase decrement by 8
                BSF             TEMP,4  
                CPFSGT          AARGB0			; if highbyte=0, result=0
                BRA             RES024

TNIB3224B       MOVLW           0xF0                    ; test if highnibble=0
                ANDWF           AARGB0,W
                TSTFSZ          WREG
                BRA             NORM3224B
                SWAPF           AARGB0,F                ; if so, shift 4 bits

                BSF             TEMP,2                  ; increase decrement by 4

NORM3224B       BCF             _C                      ; clear carry bit

                BTFSC           AARGB0,MSB		; if MSB=1, normalization done
                BRA             TNORMUN3224
                RLCF            AARGB0,F                ; otherwise, shift left and 
                INCF            TEMP,F			; increment decrement
                BTFSC           AARGB0,MSB
                BRA             TNORMUN3224
                RLCF            AARGB0,F
                INCF            TEMP,F
                BTFSC           AARGB0,MSB		; since highnibble != 0, at most
                BRA             TNORMUN3224             ; 3 left shifts are required
                RLCF            AARGB0,F 
                INCF            TEMP,F
                BRA             TNORMUN3224

;**********************************************************************************************
;**********************************************************************************************

;       Float to integer conversion

;       Input:  24 bit floating point number in AEXP, AARGB0, AARGB1

;       Use:    CALL    INT2416
;               CALL    INT24

;       Output: 16 bit 2's complement integer right justified in AARGB0, AARGB1

;       Result: AARG  <--  INT( AARG )

;       Max Timing:     10+36+12 = 58 clks              RND = 0
;                       10+36+20 = 66 clks              RND = 1, SAT = 0
;                       10+36+24 = 70 clks              RND = 1, SAT = 1

;       Min Timing:     4 clks

;       PM: 127                                         DM: 6

;----------------------------------------------------------------------------------------------

INT2416
INT24
		CLRF		AARGB2
		CLRF		WREG
		CPFSGT		EXP			; test for zero argument
		RETLW		0x00
		MOVFF           AARGB0,SIGN		; save sign in SIGN
                BSF             AARGB0,MSB		; make MSB explicit

                MOVLW           EXPBIAS+0x0F		; remove bias+15 from EXP
	        SUBWF           EXP,W

                BTFSS		WREG,MSB		; if >= 15, integer overflow
                BRA             SETIOV2416		; will occur
		MOVWF		EXP
                NEGF		EXP

                MOVLW           7                       ; do byte shift if EXP >= 8
                CPFSGT          EXP
                BRA             SNIB2416
                SUBWF           EXP,F			; EXP = EXP - 7
                MOVFF		AARGB1,AARGB2		; save for rounding
                MOVFF           AARGB0,AARGB1
                CLRF            AARGB0
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2416OK             ; shift completed if EXP = 0

                CPFSGT          EXP
                BRA             SNIB2416A
                SUBWF           EXP,F			; EXP = EXP - 7
                MOVFF		AARGB1,AARGB2		; save for rounding
                CLRF            AARGB1
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2416OK             ; shift completed if EXP = 0

SNIB2416B       MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2416B
                SWAPF           AARGB2,W
                ANDLW           0x0F
                MOVWF           AARGB2
                BRA             SHIFT2416OK             ; shift completed if EXP = 0

SHIFT2416B      BCF             _C                      ; at most 3 right shifts are required
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
		RRCF		AARGB2,F
                BRA             SHIFT2416OK

SNIB2416A       MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2416A
                SUBWF           EXP,F			; EXP = EXP - 3
                SWAPF           AARGB1,W
                MOVWF           AARGB2			; save for rounding
                ANDLW           0x0F
                MOVWF           AARGB1
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2416OK             ; shift completed if EXP = 0

SHIFT2416A      BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB1,F                ; right shift by EXP
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                BRA             SHIFT2416OK

SNIB2416        MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2416
                SUBWF           EXP,F			; EXP = EXP - 3
                SWAPF           AARGB1,W
                MOVWF           AARGB2			; save for rounding
                ANDLW           0x0F
                MOVWF           AARGB1
                SWAPF           AARGB0,W
                ANDLW           0xF0
                ADDWF           AARGB1,F
                SWAPF           AARGB0,W
                ANDLW           0x0F
                MOVWF           AARGB0
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2416OK             ; shift completed if EXP = 0

SHIFT2416       BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB0,F                ; right shift by EXP
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB0,F  
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          EXP,F
                BRA             SHIFT2416OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB0,F  
                RRCF            AARGB1,F
		RRCF		AARGB2,F

SHIFT2416OK
		BTFSC           FPFLAGS,RND		; is rounding enabled?
                BTFSS           AARGB2,MSB		; is NSB > 0x80?
                BRA             INT2416OK
		BSF		_C			; set carry for rounding
		MOVLW		0x80
		CPFSGT		AARGB2			; if NSB = 0x80, select even
		RRCF		AARGB1,W			; using lsb in carry
                CLRF            WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F
                BTFSC           AARGB0,MSB
                BRA             SETIOV2416

INT2416OK       BTFSS           SIGN,MSB                ; if sign bit set, negate               
                RETLW           0
                COMF            AARGB1,F
                COMF            AARGB0,F
                INFSNZ          AARGB1,F
                INCF            AARGB0,F
                RETLW           0

SETIOV2416	BSF             FPFLAGS,IOV             ; set integer overflow flag
                BTFSS           FPFLAGS,SAT             ; test for saturation
                RETLW           0xFF                    ; return error code in WREG

                CLRF            AARGB0			; saturate to largest two's
                BTFSS           SIGN,MSB                ; complement 16 bit integer
                SETF            AARGB0                  ; SIGN = 0, 0x 7F FF
                MOVFF           AARGB0,AARGB1           ; SIGN = 1, 0x 80 00
                RLCF            SIGN,F
                RRCF            AARGB0,F
                RETLW           0xFF                    ; return error code in WREG

;**********************************************************************************************
;**********************************************************************************************

;       Float to integer conversion

;       Input:  24 bit floating point number in AEXP, AARGB0, AARGB1

;       Use:    CALL    INT2424

;       Output: 24 bit 2's complement integer right justified in AARGB0, AARGB1, AARGB2

;       Result: AARG  <--  INT( AARG )

;       Max Timing:     11+45+15 = 71 clks              RND = 0
;                       11+45+23 = 79 clks              RND = 1, SAT = 0
;                       11+45+26 = 82 clks              RND = 1, SAT = 1

;       Min Timing:     4 clks  

;       PM: 185                                         DM: 7

;----------------------------------------------------------------------------------------------

INT2424
		CLRF		AARGB2
		CLRF		WREG
		CPFSGT		EXP			; test for zero argument
		RETLW		0x00
		MOVFF           AARGB0,SIGN		; save sign in SIGN
                BSF             AARGB0,MSB		; make MSB explicit

                CLRF            AARGB3

                MOVLW           EXPBIAS+0x17		; remove bias+23 from EXP
	        SUBWF           EXP,W

                BTFSS		WREG,MSB		; if >= 23, integer overflow
                BRA             SETIOV2424		; will occur
		MOVWF		EXP
                NEGF            EXP

                MOVLW           7                       ; do byte shift if EXP >= 8
                CPFSGT          EXP
                BRA             SNIB2424
                SUBWF           EXP,F			; EXP = EXP - 7
                MOVFF           AARGB2,AARGB3		; save for rounding
                MOVFF           AARGB1,AARGB2
                MOVFF           AARGB0,AARGB1
                CLRF            AARGB0
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

                CPFSGT          EXP                     ; do another byte shift if EXP >= 8
                BRA             SNIB2424A
                SUBWF           EXP,F			; EXP = EXP - 7
                MOVFF           AARGB2,AARGB3		; save for rounding
                MOVFF           AARGB1,AARGB2
                CLRF            AARGB1
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

                CPFSGT          EXP                     ; do another byte shift if EXP >= 8
                BRA             SNIB2424B
                SUBWF           EXP,F			; EXP = EXP - 7
                MOVFF           AARGB2,AARGB3		; save for rounding
                CLRF            AARGB2
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

SNIB2424C       MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2424C
                SWAPF           AARGB3,W
                ANDLW           0x0F
                MOVWF           AARGB3
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

SHIFT2424C      BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB3,F                ; right shift by EXP
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB3,F
                BRA             SHIFT2424OK

SNIB2424B       MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2424B
                SUBWF           EXP,F			; EXP = EXP - 3
                SWAPF           AARGB2,W
                MOVWF           AARGB3			; save for rounding
                ANDLW           0x0F
                MOVWF           AARGB2
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

SHIFT2424B      BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB2,F                ; right shift by EXP
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                BRA             SHIFT2424OK

SNIB2424A       MOVLW           3                       ; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2424A
                SUBWF           EXP,F			; EXP = EXP - 3
                SWAPF           AARGB2,W
                MOVWF           AARGB3			; save for rounding
                ANDLW           0x0F
                MOVWF           AARGB2

                SWAPF           AARGB1,W
                ANDLW           0xF0
                ADDWF           AARGB2,F

                SWAPF           AARGB1,W
                ANDLW           0x0F
                MOVWF           AARGB1
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

SHIFT2424A      BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB1,F                ; right shift by EXP
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB1,F
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB1,F
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                BRA             SHIFT2424OK

SNIB2424        MOVLW           3			; do nibble shift if EXP >= 4
                CPFSGT          EXP
                BRA             SHIFT2424
                SUBWF           EXP,F			; EXP = EXP - 3
                SWAPF           AARGB2,W
                MOVWF           AARGB3			; save for rounding
                ANDLW           0x0F
                MOVWF           AARGB2

                SWAPF           AARGB1,W
                ANDLW           0xF0
                ADDWF           AARGB2,F

                SWAPF           AARGB1,W
                ANDLW           0x0F
                MOVWF           AARGB1

                SWAPF           AARGB0,W
                ANDLW           0xF0
                ADDWF           AARGB1,F

                SWAPF           AARGB0,W
                ANDLW           0x0F
                MOVWF           AARGB0
                DCFSNZ          EXP,F			; EXP = EXP - 1
                BRA             SHIFT2424OK             ; shift completed if EXP = 0

SHIFT2424       BCF             _C                      ; at most 3 right shifts are required
                RRCF            AARGB0,F                ; right shift by EXP
                RRCF            AARGB1,F
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB0,F
                RRCF            AARGB1,F
                RRCF            AARGB2,F
		RRCF		AARGB3,F
                DCFSNZ          EXP,F
                BRA             SHIFT2424OK             ; shift completed if EXP = 0
                BCF             _C
                RRCF            AARGB0,F  
                RRCF            AARGB1,F
                RRCF            AARGB2,F
		RRCF		AARGB3,F

SHIFT2424OK
		BTFSC           FPFLAGS,RND		; is rounding enabled?
                BTFSS           AARGB3,MSB		; is NSB > 0x80?
                BRA             INT2424OK
		BSF		_C			; set carry for rounding
		MOVLW		0x80
		CPFSGT		AARGB3			; if NSB = 0x80, select even
		RRCF		AARGB2,W		; using lsb in carry
                CLRF		WREG
		ADDWFC		AARGB2,F
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F
                BTFSC           AARGB0,MSB
                BRA             SETIOV2424

INT2424OK       BTFSS           SIGN,MSB                ; if sign bit set, negate               
                RETLW           0
                COMF            AARGB2,F
                COMF            AARGB1,F
                COMF            AARGB0,F
                INCF            AARGB2,F
		CLRF		WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F
                RETLW           0

SETIOV2424	BSF             FPFLAGS,IOV             ; set integer overflow flag
                BTFSS           FPFLAGS,SAT             ; test for saturation
                RETLW           0xFF                    ; return error code in WREG

                CLRF            AARGB0			; saturate to largest two's
                BTFSS           SIGN,MSB                ; complement 24 bit integer
                SETF            AARGB0                  ; SIGN = 0, 0x 7F FF FF
                MOVFF           AARGB0,AARGB1		; SIGN = 1, 0x 80 00 00
                MOVFF           AARGB0,AARGB2
                RLCF            SIGN,F
                RRCF            AARGB0,F
                RETLW           0xFF                    ; return error code in WREG

;**********************************************************************************************
;**********************************************************************************************

;       Floating Point Multiply

;       Input:  24 bit floating point number in AEXP, AARGB0, AARGB1
;               24 bit floating point number in BEXP, BARGB0, BARGB1

;       Use:    CALL    FPM24

;       Output: 24 bit floating point product in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  AARG * BARG

;       Max Timing:     19+33+8 = 60 clks		RND = 0
;                       19+33+20 = 72 clks		RND = 1, SAT = 0
;                       19+33+27 = 79 clks		RND = 1, SAT = 1

;       Min Timing:     5+5 = 10 clks                   AARG * BARG = 0
;                       13+5+23+11 = 52 clks

;       PM: 80                             DM: 11

;----------------------------------------------------------------------------------------------

FPM24           CLRF            AARGB2			; test for zero arguments
		CLRF		WREG
                CPFSEQ          BEXP
                CPFSGT          AEXP
                BRA             RES024

M24BNE0         MOVF            AARGB0,W
                XORWF           BARGB0,W
                MOVWF           SIGN	                ; save sign in SIGN

                MOVF            BEXP,W
                ADDWF           EXP,F
                MOVLW           EXPBIAS-1
                BNC             MTUN24
        
                SUBWF           EXP,F			; remove bias and overflow test
                BC              SETFOV24
                BRA             MOK24

MTUN24          SUBWF           EXP,F			; remove bias and underflow test
                BTFSS           _C
                BRA             SETFUN24

MOK24           BSF             AARGB0,MSB              ; make argument MSB's explicit
                BSF             BARGB0,MSB

		MOVFF		AARGB1,TEMPB1	

		MOVF		AARGB1,W		; multiply mantissas
		MULWF		BARGB1
		MOVFF		PRODH,AARGB2
		
		MOVF		AARGB0,W
		MULWF		BARGB0
		MOVFF		PRODH,AARGB0
		MOVFF		PRODL,AARGB1

		MULWF		BARGB1
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F
		CLRF		WREG
		ADDWFC		AARGB0,F

		MOVF		TEMPB1,W
		MULWF		BARGB0
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F
		CLRF		WREG
		ADDWFC		AARGB0,F

		BTFSC		AARGB0,MSB		; check for postnormalization
		BRA 		MROUND24
		RLCF		AARGB2,F
		RLCF		AARGB1,F
		RLCF		AARGB0,F
		DECF		EXP,F
		BTFSC		_Z
		BRA 		SETFUN24

MROUND24
		BTFSC           FPFLAGS,RND		; is rounding enabled?
                BTFSS           AARGB2,MSB		; is NSB > 0x80?
                BRA             MUL24OK
		BSF		_C			; set carry for rounding
		MOVLW		0x80
		CPFSGT		AARGB2			; if NSB = 0x80, select even
		RRCF		AARGB1,W		; using lsb in carry
                CLRF		WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F

                BNC             MUL24OK			; has rounding caused carryout?
                RRCF            AARGB0,F                ; if so, right shift
                RRCF            AARGB1,F
                INFSNZ          EXP,F			; test for floating point overflow
                BRA             SETFOV24

MUL24OK         BTFSS           SIGN,MSB
                BCF             AARGB0,MSB		; clear explicit MSB if positive

                RETLW           0  

SETFOV24        BSF             FPFLAGS,FOV		; set floating point underflag
                BTFSS           FPFLAGS,SAT             ; test for saturation
                RETLW           0xFF                    ; return error code in WREG

                SETF            AEXP			; saturate to largest floating
                SETF            AARGB0			; point number = 0x FF 7F FF
                SETF            AARGB1			; modulo the appropriate sign bit
                RLCF            SIGN,F
                RRCF            AARGB0,F
                RETLW           0xFF			; return error code in WREG

;**********************************************************************************************
;**********************************************************************************************

;       Floating Point Divide

;       Input:  24 bit floating point dividend in AEXP, AARGB0, AARGB1
;               24 bit floating point divisor in BEXP, BARGB0, BARGB1

;       Use:    CALL    FPD24

;       Output: 24 bit floating point quotient in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  AARG / BARG

;       Max Timing:     10+12+30+38+67+19 = 176 clks		RND = 0
;                       10+12+30+38+67+28 = 185 clks		RND = 1, SAT = 0
;                       10+12+30+38+67+35 = 192 clks		RND = 1, SAT = 1

;       Min Timing:     6+5 = 11 clks                   	AARG = 0

;       PM: 201+256 = 457					DM: 13

;	In addition to those registers defined in MATH17.INC, this routine uses
;	TBLPTRL and TBLPTRH without saving and restoring.

;----------------------------------------------------------------------------------------------

FPD24SEED	macro

;       Timing:     12 clks

;	PM: 11+257 = 268

;	generation of F0 using 16 bit zeroth degree minimax approximations to the 
;	reciprocal of BARG, with the top 8 explicit bits of BARG as a pointer.

		CLRF		TBLPTRU
		MOVLW		HIGH (IBTBL256M)	; access table for F0
		MOVWF		TBLPTRH			
		RLCF		BARGB1,W		; *2
		RLCF		BARGB0,W
		BCF		_C
		RLCF		WREG,W			; *2
		BTFSC		_C
		INCF		TBLPTRH,F
		ADDLW		LOW (IBTBL256M)
		MOVWF		TBLPTRL
		BTFSC		_C
		INCF		TBLPTRH,F
		TBLRD		*+
		MOVFF		TABLAT,TEMPB1
		TBLRD		*+
		MOVFF		TABLAT,TEMPB0
		endm

;----------------------------------------------------------------------------------------------

FPD24SEEDS	macro

;       Timing:     64 clks

;	PM: 62+17 = 79

;	generation of F0 by interpolating between consecutive 16 bit approximations
;	to the reciprocal of BARG, with the top 4 explicit bits of BARG as a pointer
;	and the remaining 11 explicit bits as the argument to linear interpolation.

		CLRF		TBLPTRU
		MOVLW		HIGH (IBTBL16I)	; access table for F0
		MOVWF		TBLPTRH
		RLCF		BARGB0,W
		SWAPF		WREG,F
		ANDLW		0x0F
		ADDLW		LOW (IBTBL16I)
		MOVWF		TBLPTRL
		BTFSC		_C
		INCF		TBLPTRH,F
		TABLRD		0,1,TEMPB0
		TLRD		1,TEMPB0
		TABLRD		0,0,TEMPB1
		TLRD		1,AARGB4
		TLRD		0,AARGB5

		MOVF		AARGB5,W		; calculate difference
		SUBWF		TEMPB1,W
		MOVWF		AARGB5
		MOVF		AARGB4,W
		SUBWFB		TEMPB0,W
		MOVWF		AARGB4

		MOVFF		AARGB5,TBLPTRL
		MOVF		BARGB0,W
		ANDLW		0x07
		MOVWF		TEMPB2	

		MOVF		AARGB5,W
		MULWF		BARGB1
		MOVFF		PRODL,TBLPTRH
		
		MOVF		AARGB4,W
		MULWF		TEMPB2
		MOVFF		PRODH,AARGB4
		MOVFF		PRODL,AARGB5

		MULWF		BARGB1
		MOVF		PRODL,W
		ADDWF		TBLPTRH,F
		MOVF		PRODH,W
		ADDWFC		AARGB5,F
		CLRF		WREG
		ADDWFC		AARGB4,F

		MOVF		TBLPTRL,W
		MULWF		TEMPB2
		MOVF		PRODL,W
		ADDWF		TBLPTRH,F
		MOVF		PRODH,W
		ADDWFC		AARGB5,F
		CLRF		WREG
		ADDWFC		AARGB4,F

		BCF		_C
		RRCF		AARGB4,F
		RRCF		AARGB5,F
		RRCF		TBLPTRL,F
		BCF		_C
		RRCF		AARGB4,F
		RRCF		AARGB5,F
		RRCF		TBLPTRL,F
		BCF		_C
		RRCF		AARGB4,F
		RRCF		AARGB5,F
		RRCF		TBLPTRL,F

		MOVF		TBLPTRL,W
		SUBWF		TEMPB1,F
		MOVF		AARGB5,W
		SUBWFB		TEMPB0,F		; F0

		endm

;----------------------------------------------------------------------------------------------

FPD24           CLRF            TEMPB3			; clear exponent modification
		CLRF		WREG
                CPFSGT          BEXP			; test for divide by zero
                BRA             SETFDZ24

                CPFSGT          AEXP
                BRA             RES024
		
D24BNE0         MOVF            AARGB0,W
                XORWF           BARGB0,W
                MOVWF           SIGN	                ; save sign in SIGN

		BSF             AARGB0,MSB              ; make argument MSB's explicit
                BSF             BARGB0,MSB

		FPD24SEED				; generation of F0

		MOVFF		AARGB1,AARGB4		; A0 = F0 * A

		MOVF		AARGB1,W
		MULWF		TEMPB1
		MOVFF		PRODH,AARGB2
		MOVFF		PRODL,AARGB3
		
		MOVF		AARGB0,W
		MULWF		TEMPB0
		MOVFF		PRODH,AARGB0
		MOVFF		PRODL,AARGB1

		MULWF		TEMPB1
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F
		CLRF		WREG
		ADDWFC		AARGB0,F

		MOVF		AARGB4,W
		MULWF		TEMPB0
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F
		CLRF		WREG
		ADDWFC		AARGB0,F

		BTFSC		AARGB0,MSB
		BRA 		DAOK24
		RLCF		AARGB2,F
		RLCF		AARGB1,F
		RLCF		AARGB0,F
		DECF		TEMPB3,F

DAOK24		MOVFF		BARGB1,AARGB4		; B0 = F0 * B

		MOVF		BARGB1,W
		MULWF		TEMPB1
		MOVFF		PRODH,BARGB2
		MOVFF		PRODL,BARGB3
		
		MOVF		BARGB0,W
		MULWF		TEMPB0
		MOVFF		PRODH,BARGB0
		MOVFF		PRODL,BARGB1

		MULWF		TEMPB1
		MOVF		PRODL,W
		ADDWF		BARGB2,F
		MOVF		PRODH,W
		ADDWFC		BARGB1,F
		CLRF		WREG
		ADDWFC		BARGB0,F

		MOVF		AARGB4,W
		MULWF		TEMPB0
		MOVF		PRODL,W
		ADDWF		BARGB2,F
		MOVF		PRODH,W
		ADDWFC		BARGB1,F
		CLRF		WREG
		ADDWFC		BARGB0,F

		BTFSS		BARGB0,MSB
		BTFSC		BARGB0,MSB-1
		BRA 		DBOK24
		RLCF		BARGB3,F
		RLCF		BARGB2,F
		RLCF		BARGB1,F
		RLCF		BARGB0,F
		INCF		TEMPB3,F
		
DBOK24
		COMF		BARGB2,F		; F1 = 2 - B0
		COMF		BARGB1,F
		COMF		BARGB0,F
		INCF		BARGB2,F
		ADDWFC		BARGB1,F
		ADDWFC		BARGB0,F

		MOVFF		AARGB0,TEMPB0		; A1 = F1 * A	
		MOVFF		AARGB1,TEMPB1	
		MOVFF		AARGB2,TEMPB2	
		
		MOVF		AARGB1,W
		MULWF		BARGB1
		MOVFF		PRODH,AARGB2
		MOVFF		PRODL,AARGB3

		MULWF		BARGB2
		MOVF		PRODH,W
		ADDWF		AARGB3,F
		CLRF		WREG
		ADDWFC		AARGB2,F

		MOVF		TEMPB2,W
		MULWF		BARGB1
		MOVF		PRODH,W
		ADDWF		AARGB3,F
		CLRF		WREG
		ADDWFC		AARGB2,F
	
		MOVF		AARGB0,W
		MULWF		BARGB2
		MOVF		PRODL,W
		ADDWF		AARGB3,F
		MOVF		PRODH,W
		ADDWFC		AARGB2,F
		MOVF		AARGB0,W
		MULWF		BARGB1
		CLRF		AARGB1
		CLRF		WREG
		ADDWFC		AARGB1,F
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F

		MOVF		TEMPB2,W
		MULWF		BARGB0
		MOVF		PRODL,W
		ADDWF		AARGB3,F
		MOVF		PRODH,W
		ADDWFC		AARGB2,F
		CLRF		AARGB0
		CLRF		WREG
		ADDWFC		AARGB1,F
		ADDWFC		AARGB0,F

		MOVF		TEMPB1,W
		MULWF		BARGB0
		MOVF		PRODL,W
		ADDWF		AARGB2,F
		MOVF		PRODH,W
		ADDWFC		AARGB1,F
		CLRF		WREG
		ADDWFC		AARGB0,F

		MOVF		TEMPB0,W
		MULWF		BARGB0
		MOVF		PRODL,W
		ADDWF		AARGB1,F
		MOVF		PRODH,W
		ADDWFC		AARGB0,F

		BTFSC		AARGB0,MSB		; postnormalization
		BRA 		DNORM24
		RLCF		AARGB2,F
		RLCF		AARGB1,F
		RLCF		AARGB0,F
		DECF		TEMPB3,F
DNORM24
		BTFSC		AARGB0,MSB
		BRA 		DEXP24
		RLCF		AARGB2,F
		RLCF		AARGB1,F
		RLCF		AARGB0,F
		DECF		TEMPB3,F
DEXP24
		MOVF            BEXP,W	                ; compute AEXP - BEXP
                SUBWF           EXP,F
                MOVLW           EXPBIAS+1		; add bias + 1 for scaling of F0
                BNC             ALTB24
        
AGEB24		ADDWF		TEMPB3,W
		ADDWF           EXP,F			; if AEXP > BEXP, test for overflow
                BTFSC           _C
                BRA             SETFOV24
                BRA             DROUND24

ALTB24		ADDWF		TEMPB3,W
		ADDWF           EXP,F			; if AEXP < BEXP, test for underflow
                BNC             SETFUN24

DROUND24
		BTFSC           FPFLAGS,RND		; is rounding enabled?
                BTFSS           AARGB2,MSB		; is NSB > 0x80?
                BRA             DIV24OK
		BSF		_C			; set carry for rounding
		MOVLW		0x80
		CPFSGT		AARGB2			; if NSB = 0x80, select even
		RRCF		AARGB1,W			; using lsb in carry
                CLRF            WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F

                BNC             DIV24OK
                RRCF            AARGB0,F
                RRCF            AARGB1,F
                INFSNZ          EXP,F			; test for overflow
                BRA             SETFOV24

DIV24OK         BTFSS           SIGN,MSB
                BCF             AARGB0,MSB               ; clear explicit MSB if positive

                RETLW           0

SETFUN24        BSF             FPFLAGS,FUN             ; set floating point underflag
                BTFSS           FPFLAGS,SAT             ; test for saturation
                RETLW           0xFF                    ; return error code in WREG

                MOVLW           0x01                    ; saturate to smallest floating
                MOVWF           AEXP                    ; point number = 0x 01 00 00
                CLRF            AARGB0			; modulo the appropriate sign bit
                CLRF            AARGB1
                RLCF            SIGN,F
                RRCF            AARGB0,F
                RETLW           0xFF                    ; return error code in WREG

SETFDZ24        BSF             FPFLAGS,FDZ             ; set floating point divide by zero
                RETLW           0xFF                    ; flag and return error code in 
                                                        ; WREG

;----------------------------------------------------------------------------------------------

;	table of  16 bit approximations to the reciprocal of BARG,
;	with the top 4 explicit bits of BARG as a pointer and the
;	remaining 11 explicit bits as the argument to linear interpolation.

;IBTBL16I
;		DATA	0xFFFF
;		DATA	0xF0F1
;		DATA	0xE38E
;		DATA	0xD794
;		DATA	0xCCCD
;		DATA	0xC30C
;		DATA	0xBA2F
;		DATA	0xB216
;		DATA	0xAAAB
;		DATA	0xA3D7
;		DATA	0x9D8A
;		DATA	0x97B4
;		DATA	0x9249
;		DATA	0x8D3E
;		DATA	0x8889
;		DATA	0x8421
;		DATA	0x8001

;	table of 16 bit zeroth degree minimax approximations to the 
;	reciprocal of BARG, with the top 8 explicit bits of BARG as a pointer.

IBTBL256M
		DATA	0xFF81
		DATA	0xFE83
		DATA	0xFD87
		DATA	0xFC8D
		DATA	0xFB95
		DATA	0xFA9E
		DATA	0xF9AA
		DATA	0xF8B7
		DATA	0xF7C7
		DATA	0xF6D8
		DATA	0xF5EB
		DATA	0xF4FF
		DATA	0xF416
		DATA	0xF32E
		DATA	0xF248
		DATA	0xF163
		DATA	0xF080
		DATA	0xEF9F
		DATA	0xEEC0
		DATA	0xEDE2
		DATA	0xED06
		DATA	0xEC2B
		DATA	0xEB52
		DATA	0xEA7A
		DATA	0xE9A4
		DATA	0xE8D0
		DATA	0xE7FD
		DATA	0xE72B
		DATA	0xE65B
		DATA	0xE58D
		DATA	0xE4C0
		DATA	0xE3F4
		DATA	0xE32A
		DATA	0xE261
		DATA	0xE199
		DATA	0xE0D3
		DATA	0xE00E
		DATA	0xDF4B
		DATA	0xDE89
		DATA	0xDDC8
		DATA	0xDD09
		DATA	0xDC4A
		DATA	0xDB8D
		DATA	0xDAD2
		DATA	0xDA17
		DATA	0xD95E
		DATA	0xD8A6
		DATA	0xD7EF
		DATA	0xD73A
		DATA	0xD686
		DATA	0xD5D2
		DATA	0xD520
		DATA	0xD470
		DATA	0xD3C0
		DATA	0xD311
		DATA	0xD264
		DATA	0xD1B7
		DATA	0xD10C
		DATA	0xD062
		DATA	0xCFB9
		DATA	0xCF11
		DATA	0xCE6A
		DATA	0xCDC4
		DATA	0xCD1F
		DATA	0xCC7B
		DATA	0xCBD8
		DATA	0xCB37
		DATA	0xCA96
		DATA	0xC9F6
		DATA	0xC957
		DATA	0xC8B9
		DATA	0xC81C
		DATA	0xC780
		DATA	0xC6E5
		DATA	0xC64B
		DATA	0xC5B2
		DATA	0xC51A
		DATA	0xC483
		DATA	0xC3EC
		DATA	0xC357
		DATA	0xC2C2
		DATA	0xC22E
		DATA	0xC19C
		DATA	0xC10A
		DATA	0xC078
		DATA	0xBFE8
		DATA	0xBF59
		DATA	0xBECA
		DATA	0xBE3C
		DATA	0xBDAF
		DATA	0xBD23
		DATA	0xBC98
		DATA	0xBC0D
		DATA	0xBB84
		DATA	0xBAFB
		DATA	0xBA72
		DATA	0xB9EB
		DATA	0xB964
		DATA	0xB8DF
		DATA	0xB859
		DATA	0xB7D5
		DATA	0xB751
		DATA	0xB6CE
		DATA	0xB64C
		DATA	0xB5CB
		DATA	0xB54A
		DATA	0xB4CA
		DATA	0xB44B
		DATA	0xB3CC
		DATA	0xB34E
		DATA	0xB2D1
		DATA	0xB254
		DATA	0xB1D8
		DATA	0xB15D
		DATA	0xB0E3
		DATA	0xB069
		DATA	0xAFF0
		DATA	0xAF77
		DATA	0xAEFF
		DATA	0xAE88
		DATA	0xAE11
		DATA	0xAD9B
		DATA	0xAD26
		DATA	0xACB1
		DATA	0xAC3D
		DATA	0xABC9
		DATA	0xAB56
		DATA	0xAAE4
		DATA	0xAA72
		DATA	0xAA01
		DATA	0xA990
		DATA	0xA920
		DATA	0xA8B1
		DATA	0xA842
		DATA	0xA7D3
		DATA	0xA766
		DATA	0xA6F8
		DATA	0xA68C
		DATA	0xA620
		DATA	0xA5B4
		DATA	0xA549
		DATA	0xA4DF
		DATA	0xA475
		DATA	0xA40C
		DATA	0xA3A3
		DATA	0xA33A
		DATA	0xA2D2
		DATA	0xA26B
		DATA	0xA204
		DATA	0xA19E
		DATA	0xA138
		DATA	0xA0D3
		DATA	0xA06E
		DATA	0xA00A
		DATA	0x9FA6
		DATA	0x9F43
		DATA	0x9EE0
		DATA	0x9E7E
		DATA	0x9E1C
		DATA	0x9DBA
		DATA	0x9D59
		DATA	0x9CF9
		DATA	0x9C99
		DATA	0x9C39
		DATA	0x9BDA
		DATA	0x9B7C
		DATA	0x9B1D
		DATA	0x9AC0
		DATA	0x9A62
		DATA	0x9A05
		DATA	0x99A9
		DATA	0x994D
		DATA	0x98F1
		DATA	0x9896
		DATA	0x983B
		DATA	0x97E1
		DATA	0x9787
		DATA	0x972E
		DATA	0x96D5
		DATA	0x967C
		DATA	0x9624
		DATA	0x95CC
		DATA	0x9574
		DATA	0x951D
		DATA	0x94C7
		DATA	0x9470
		DATA	0x941A
		DATA	0x93C5
		DATA	0x9370
		DATA	0x931B
		DATA	0x92C7
		DATA	0x9273
		DATA	0x921F
		DATA	0x91CC
		DATA	0x9179
		DATA	0x9127
		DATA	0x90D5
		DATA	0x9083
		DATA	0x9031
		DATA	0x8FE0
		DATA	0x8F90
		DATA	0x8F3F
		DATA	0x8EEF
		DATA	0x8EA0
		DATA	0x8E50
		DATA	0x8E02
		DATA	0x8DB3
		DATA	0x8D65
		DATA	0x8D17
		DATA	0x8CC9
		DATA	0x8C7C
		DATA	0x8C2F
		DATA	0x8BE2
		DATA	0x8B96
		DATA	0x8B4A
		DATA	0x8AFE
		DATA	0x8AB3
		DATA	0x8A68
		DATA	0x8A1E
		DATA	0x89D3
		DATA	0x8989
		DATA	0x893F
		DATA	0x88F6
		DATA	0x88AD
		DATA	0x8864
		DATA	0x881B
		DATA	0x87D3
		DATA	0x878B
		DATA	0x8744
		DATA	0x86FC
		DATA	0x86B5
		DATA	0x866F
		DATA	0x8628
		DATA	0x85E2
		DATA	0x859C
		DATA	0x8557
		DATA	0x8511
		DATA	0x84CC
		DATA	0x8487
		DATA	0x8443
		DATA	0x83FF
		DATA	0x83BB
		DATA	0x8377
		DATA	0x8334
		DATA	0x82F1
		DATA	0x82AE
		DATA	0x826B
		DATA	0x8229
		DATA	0x81E7
		DATA	0x81A5
		DATA	0x8164
		DATA	0x8122
		DATA	0x80E1
		DATA	0x80A1
		DATA	0x8060
		DATA	0x8020

;**********************************************************************************************
;**********************************************************************************************

;       Floating Point Subtract

;       Input:  24 bit floating point number in AEXP, AARGB0, AARGB1
;               24 bit floating point number in BEXP, BARGB0, BARGB1

;       Use:    CALL FPS24

;       Output: 24 bit floating point difference in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  AARG - BARG

;       Max Timing:     1+133 = 134 clks                RND = 0
;                       1+146 = 147 clks                RND = 1, SAT = 0
;                       1+152 = 153 clks                RND = 1, SAT = 1

;       Min Timing:     1+10 = 11 clks

;       PM: 1+298 = 299                         DM: 10

;----------------------------------------------------------------------------------------------

FPS24           BTG             BARGB0,MSB              ; toggle sign bit for subtraction

;**********************************************************************************************

;       Floating Point Add

;       Input:  24 bit floating point number in AEXP, AARGB0, AARGB1
;               24 bit floating point number in BEXP, BARGB0, BARGB1

;       Use:    CALL FPA24

;       Output: 24 bit floating point sum in AEXP, AARGB0, AARGB1

;       Result: AARG  <--  AARG - BARG

;       Max Timing:     81+52 = 133 clks             RND = 0
;                       81+65 = 146 clks             RND = 1, SAT = 0
;                       81+71 = 152 clks             RND = 1, SAT = 1

;       Min Timing:     10 clks

;       PM: 298                                         DM: 10

;----------------------------------------------------------------------------------------------

FPA24           MOVF            AARGB0,W                ; exclusive or of signs in TEMP
                XORWF           BARGB0,W
                MOVWF           TEMP

		CLRF		AARGB2			; clear extended byte

                MOVF            AEXP,W                  ; use AARG if AEXP >= BEXP
                CPFSGT          BEXP
                BRA             USEA24

USEB24		MOVF            BARGB0,W                ; use BARG if AEXP < BEXP
                MOVWF           SIGN                    ; save sign in SIGN
                BSF             BARGB0,MSB              ; make MSB's explicit
                BSF             AARGB0,MSB

                MOVF            AEXP,W                  ; compute shift count in BEXP
		MOVWF		TEMPB1
                MOVF            BEXP,W
		MOVWF		AEXP

		CLRF		WREG
		CPFSGT		TEMPB1			; return BARG if AARG = 0
                BRA             BRETURN24
		MOVF		TEMPB1,W
                SUBWF           BEXP,F
                BZ              BLIGNED24

                MOVLW           7
                CPFSGT          BEXP                    ; do byte shift if BEXP >= 8 
                BRA             BNIB24
                SUBWF           BEXP,F			; BEXP = BEXP - 7
                MOVFF           AARGB1,AARGB2           ; keep for postnormalization
                MOVFF           AARGB0,AARGB1
                CLRF            AARGB0
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             BLIGNED24

                CPFSGT          BEXP                    ; do byte shift if BEXP >= 8
                BRA             BNIB24A
                SUBWF           BEXP,F			; BEXP = BEXP - 7
                MOVFF           AARGB1,AARGB2           ; keep for postnormalization
                CLRF            AARGB1
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             BLIGNED24

                CPFSGT          BEXP                    ; if BEXP still >= 8, then
                BRA             BNIB24B                 ; AARG = 0 relative to BARG

BRETURN24	MOVFF           SIGN,AARGB0             ; return BARG
                MOVFF           BARGB1,AARGB1
		CLRF		AARGB2
                RETLW           0x00

BNIB24B         MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             BLOOP24B
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		AARGB2,W
		ANDLW		0x0F
		MOVWF		AARGB2
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             BLIGNED24               ; aligned if BEXP = 0

BLOOP24B        BCF             _C                      ; right shift by BEXP
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            AARGB2,F                ; possible
		BRA             BLIGNED24

BNIB24A         MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             BLOOP24A
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		AARGB2,W
		ANDLW		0x0F
		MOVWF		AARGB2
                SWAPF           AARGB1,W
                ANDLW           0xF0
		ADDWF		AARGB2,F
		SWAPF		AARGB1,W
		ANDLW		0x0F
                MOVWF           AARGB1
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             BLIGNED24               ; aligned if BEXP = 0

BLOOP24A        BCF             _C                      ; right shift by BEXP
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            AARGB1,F                ; possible
		RRCF		AARGB2,F
                BRA             BLIGNED24

BNIB24          MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             BLOOP24
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		AARGB2,W
		ANDLW		0x0F
		MOVWF		AARGB2
                SWAPF           AARGB1,W
                ANDLW           0xF0
		ADDWF		AARGB2,F
		SWAPF		AARGB1,W
		ANDLW		0x0F
                MOVWF           AARGB1
                SWAPF           AARGB0,W
                ANDLW           0xF0
                ADDWF           AARGB1,F
                SWAPF           AARGB0,W
                ANDLW           0x0F
                MOVWF           AARGB0
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             BLIGNED24               ; aligned if BEXP = 0

BLOOP24         BCF             _C                      ; right shift by BEXP
                RRCF            AARGB0,F
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C
                RRCF            AARGB0,F
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                DCFSNZ          BEXP,F
                BRA             BLIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            AARGB0,F                ; possible
                RRCF            AARGB1,F
		RRCF		AARGB2,F

BLIGNED24	CLRF		BARGB2
		CLRF		WREG
		BTFSS           TEMP,MSB                ; negate if signs opposite
                BRA             AOK24
		COMF		AARGB2,F
                COMF            AARGB1,F
                COMF            AARGB0,F
                INCF		AARGB2,F
		ADDWFC		AARGB1,F
		ADDWFC		AARGB0,F
                BRA             AOK24

USEA24		TSTFSZ		BEXP                    ; return AARG if BARG = 0
		BRA 		BNE024
		RETLW		0x00

BNE024		CLRF		BARGB2
                MOVFF           AARGB0,SIGN             ; save sign in SIGN
                BSF             AARGB0,MSB              ; make MSB's explicit
                BSF             BARGB0,MSB

                MOVF            BEXP,W                  ; compute shift count in BEXP
                SUBWF           AEXP,W
                MOVWF           BEXP
                BZ              ALIGNED24

                MOVLW           7
                CPFSGT          BEXP                    ; do byte shift if BEXP >= 8 
                BRA             ANIB24

                SUBWF           BEXP,F			; BEXP = BEXP - 7
                MOVF            BARGB1,W
		MOVWF		BARGB2                  ; keep for postnormalization
                MOVF            BARGB0,W
                MOVWF           BARGB1
                CLRF            BARGB0
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             ALIGNED24

                MOVLW           7
                CPFSGT          BEXP                    ; if BEXP still >= 8, then
                BRA             ANIB24A                 ; BARG = 0 relative to AARG

                SUBWF           BEXP,F			; BEXP = BEXP - 7
                MOVF            BARGB1,W
		MOVWF		BARGB2                  ; keep for postnormalization
                CLRF            BARGB1
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             ALIGNED24

                MOVLW           7
                CPFSGT          BEXP                    ; if BEXP still >= 8, then
                BRA             ANIB24B                 ; BARG = 0 relative to AARG

                MOVFF           SIGN,AARGB0             ; return AARG
                RETLW           0x00

ANIB24B         MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             ALOOP24B
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		BARGB2,W
		ANDLW		0x0F
		MOVWF		BARGB2
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             ALIGNED24               ; aligned if BEXP = 0

ALOOP24B        BCF             _C                      ; right shift by BEXP
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            BARGB2,F                ; possible
		BRA             ALIGNED24

ANIB24A         MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             ALOOP24A
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		BARGB2,W
		ANDLW		0x0F
		MOVWF		BARGB2
                SWAPF           BARGB1,W
                ANDLW           0xF0
		ADDWF		BARGB2,F
		SWAPF		BARGB1,W
		ANDLW		0x0F
                MOVWF           BARGB1
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             ALIGNED24               ; aligned if BEXP = 0

ALOOP24A        BCF             _C                      ; right shift by BEXP
                RRCF            BARGB1,F
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C
                RRCF            BARGB1,F
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            BARGB1,F                ; possible
		RRCF		BARGB2,F
                BRA             ALIGNED24

ANIB24          MOVLW           3                       ; do nibbleshift if BEXP >= 4
                CPFSGT          BEXP
                BRA             ALOOP24
                SUBWF           BEXP,F			; BEXP = BEXP -3
		SWAPF		BARGB2,W
		ANDLW		0x0F
		MOVWF		BARGB2
                SWAPF           BARGB1,W
                ANDLW           0xF0
		ADDWF		BARGB2,F
		SWAPF		BARGB1,W
		ANDLW		0x0F
                MOVWF           BARGB1
                SWAPF           BARGB0,W
                ANDLW           0xF0
                ADDWF           BARGB1,F
                SWAPF           BARGB0,W
                ANDLW           0x0F
                MOVWF           BARGB0
                DCFSNZ          BEXP,F			; BEXP = BEXP - 1
                BRA             ALIGNED24               ; aligned if BEXP = 0

ALOOP24         BCF             _C                      ; right shift by BEXP
                RRCF            BARGB0,F
                RRCF            BARGB1,F
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C
                RRCF            BARGB0,F
                RRCF            BARGB1,F
		RRCF		BARGB2,F
                DCFSNZ          BEXP,F
                BRA             ALIGNED24               ; aligned if BEXP = 0
                BCF             _C                      ; at most 3 right shifts are
                RRCF            BARGB0,F                ; possible
                RRCF            BARGB1,F
		RRCF		BARGB2,F

ALIGNED24	CLRF		AARGB2
		CLRF		WREG
		BTFSS           TEMP,MSB                ; negate if signs opposite
                BRA             AOK24
		COMF		BARGB2,F
                COMF            BARGB1,F
                COMF            BARGB0,F
                INCF		BARGB2,F
                ADDWFC          BARGB1,F
                ADDWFC          BARGB0,F

AOK24		MOVF		BARGB2,W
		ADDWF		AARGB2,F
		MOVF            BARGB1,W                ; add
                ADDWFC		AARGB1,F
                MOVF            BARGB0,W
                ADDWFC          AARGB0,F

                BTFSC           TEMP,MSB
                BRA             ACOMP24
                BTFSS           _C
                GOTO            NRMRND3224

                RRCF            AARGB0,F               ; shift right and increment EXP
                RRCF            AARGB1,F
		RRCF		AARGB2,F
                INCFSZ          AEXP,F
                GOTO            NRMRND3224
                BRA             SETFOV24               ; set floating point overflow flag

ACOMP24         BTFSC           _C
                GOTO            NRM3224                ; normalize and fix sign

                COMF            AARGB2,F               ; negate, toggle sign bit and
                COMF            AARGB1,F               ; then normalize
		COMF		AARGB0,F
                INCF		AARGB2,F
		CLRF		WREG
                ADDWFC          AARGB1,F
                ADDWFC          AARGB0,F
                BTG             SIGN,MSB
                GOTO            NRM3224

